---
sidebar_position: 3
---

# How to Build a Contract Tx

## Introduction

When you've finished writing an scryptTS contract, you might want to deploy and call it. But first, you should learn more about how the contract interacts with the blockchain.

As explained in the [Overview section](../overview.md), a scryptTS contract is based on the Bitcoin UTXO model. In this section, we will go over these fundamental concepts in greater detail.


## Contract Deployment Transaction

A deploy transaction is required when attempting to deploy an scryptTS contract to the blockchain. The transaction should have an output that contains the Bitcoin script generated by the contract as the locking script. This output is known as a contract UTXO, and we say the contract instance comes from this UTXO.

The binding between an instance and an UTXO is typically expressed as code like this:
```ts
instance.from = { tx, outputIndex }
```

## Contract Call Transaction

When you try to call a method of an scryptTS contract instance that exists on the blockchain, a call transaction is needed. The transaction should have an input that contains the Bitcoin script generated from the method arguments, and the input should spend the UTXO of the same contract instance. We say the contract instance goes to this transaction input.

The binding between an instance and an input is typically expressed as code like this:

```ts
instance.to = { tx, inputIndex }
```

This section could be summarized as the diagram below:

![](../../static/img/contract_tx.svg)

## Tx Builders

We now know that in order to deploy or make calls for contracts, transactions must be built. How can the task be accomplished in code?


Thankfully, we have some built-in TX builders for common contracts, so you don't have to worry about how to implement them.

### Deployment Tx Builder

For contract deployment, the built-in Tx builder produces a transaction with the following structure:

* Inputs:

  * [0…]: Several P2PKH inputs for paying transaction fees.

* Outputs:

  * [0]: The output where the contract’s genesis instance comes from.
  * [1]: A change output if needed.

Because contract deployment transactions can use this structure for any contracts right now, you don’t have to provide your own version.

### Default Call Tx Builder

For contract calls, the built-in default Tx builder produces a transaction with the following structure:

* Inputs

  * [0]: The input that spends the previous contract UTXO with script generated from calling the contract instance’s method.
  * [1…]: Several P2PKH inputs for paying transaction fees.

* Outputs

  * [0…N-1]: Several outputs that each contain a new contract instance (UTXO) if the contract is stateful.
  * [N]: A change output if needed.


### Customized Call Tx builder

If the default Tx builder does not meet your specific requirements, such as having other specified inputs or outputs in your Tx, you can define a customized Tx builder for a public method of your contract.

Usually you can define a customized Tx builder for a contract @method like this:

```ts
// bind a customized tx builder for `MyContract.unlock`
MyContract.bindTxBuilder("unlock", (options, ...args) => { 

  let result: Promise<BuildMethodCallTxResult<MyContract>>;

  const current = options.current;

  const unsignedTx: bsv.Transaction = new bsv.Transaction()
    // add contract input
    .addInput(current.buildContractInput(options.fromUTXO))
    // add p2pkh inputs
    .from(options.utxos)
    // add an extra p2pkh output
    .addOutput(new bsv.Transaction.Output({
        script: bsv.Script.fromHex(Utils.buildPublicKeyHashScript(args[0])),
        satoshis: args[1]
    }))
    // add change output
    .change(options.changeAddress);

  result = {
    unsignedTx,
    atInputIndex: 0
  };

  return Promise.resolve(result)         
})
```

Please be aware that your customized Tx builder must always deliver a transaction that adheres to your public method's logic and the hash type of its signature. More information can be found in [this section](./what-is-scriptcontext.md).

Following the instructions in the next section, you could then begin testing your contracts.
