---
sidebar_position: 3
---

# How to Build a Contract Tx

## Introduction

When you've finished writing a contract, you might want to deploy and call it. But first, you should learn more about how the contract interacts with the blockchain.

As explained in the [Overview section](../overview.md), a scryptTS contract is based on the Bitcoin UTXO model. In this section, we will go over these fundamental concepts in greater detail.


### Contract Deployment Transaction

A deploy transaction is required when attempting to deploy a contract to the blockchain. The transaction should have an output that contains the Bitcoin script generated by the contract as the locking script. This output is known as a contract UTXO, and we say the contract instance comes from this UTXO.

The binding between an instance and an UTXO is typically expressed as code like this:
```ts
instance.from = { tx, outputIndex }
```

And you can access the reference like this:

```ts
instance.from.tx;
instance.from.outputIndex;
```

### Contract Call Transaction

When you try to call a method of a contract instance that exists on the blockchain, a call transaction is needed. The transaction should have an input that contains the Bitcoin script generated from the method arguments, and the input should spend the UTXO of the same contract instance. We say the contract instance goes to this transaction input.

The binding between an instance and an input is typically expressed as code like this:

```ts
instance.to = { tx, inputIndex }
```

And you can access the reference like this:

```ts
instance.to.tx;
instance.to.inputIndex;
```


This section could be summarized as the diagram below:

![](../../static/img/contract_tx.svg)

## Tx Builders

We now know that in order to deploy or make calls for contracts, transactions must be built.


Thankfully, we have some built-in tx builders for common contracts, so you don't have to worry about how to implement them.

### Deployment Tx Builder

For contract deployment, the built-in tx builder produces a transaction with the following structure:

* Inputs:

  * [0…]: Several [P2PKH](https://learnmeabitcoin.com/technical/p2pkh) inputs for paying transaction fees.

* Outputs:

  * [0]: The output containing the contract.
  * [1]: A P2PKH change output if needed.

Because contract deployment transactions can use this structure for any contracts right now, you don’t have to provide your own version.

### Default Call Tx Builder

For contract calls, the built-in default tx builder produces a transaction with the following structure:

* Inputs

  * [0]: The input that spends the previous contract UTXO with script generated from calling the contract instance’s method.
  * [1…]: Several P2PKH inputs for paying transaction fees.

* Outputs

  * [0…N-1]: Several outputs, each contains a new contract instance (UTXO) if the contract is stateful.
  * [N]: A P2PKH change output if needed.


### Customized Call Tx builder

If the default tx builder does not meet your specific requirements, such as having other specified inputs or outputs in your tx, you can define a customized tx builder for a public `@method` of your contract.

You can define it like this:

```ts
// bind a customized tx builder for `MyContract.unlock`
MyContract.bindTxBuilder("unlock", (options, ...args) => { 

  let result: Promise<BuildMethodCallTxResult<MyContract>>;

  // the contract instance
  const current = options.current;

  const unsignedTx: bsv.Transaction = new bsv.Transaction()
    // add contract input
    .addInput(current.buildContractInput(options.fromUTXO))
    // add p2pkh inputs
    .from(options.utxos)
    // add an extra p2pkh output
    .addOutput(new bsv.Transaction.Output({
        script: bsv.Script.fromHex(Utils.buildPublicKeyHashScript(args[0])),
        satoshis: args[1]
    }))
    // add change output
    .change(options.changeAddress);

  result = {
    unsignedTx,
    atInputIndex: 0 // the contract input's index
  };

  return Promise.resolve(result)         
})
```

## Heads up

Please be aware that each of these tx builders should only create an unsigned transaction. The framework will automatically process it.

Also, please be aware that your customized tx builder must always deliver a transaction that adheres to your public `@method`'s logic, i.e., making all assertions executed in it pass.

Following the instructions in the next section, you could then begin testing your contracts.
