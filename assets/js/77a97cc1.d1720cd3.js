"use strict";(self.webpackChunkscrypt_ts_docs=self.webpackChunkscrypt_ts_docs||[]).push([[736],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var o=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function c(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,o,a=function(t,e){if(null==t)return{};var n,o,a={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var l=o.createContext({}),s=function(t){var e=o.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):c(c({},e),t)),n},p=function(t){var e=s(t.components);return o.createElement(l.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},u=o.forwardRef((function(t,e){var n=t.components,a=t.mdxType,r=t.originalType,l=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),u=s(n),h=a,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||r;return n?o.createElement(m,c(c({ref:e},p),{},{components:n})):o.createElement(m,c({ref:e},p))}));function h(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var r=n.length,c=new Array(r);c[0]=u;var i={};for(var l in e)hasOwnProperty.call(e,l)&&(i[l]=e[l]);i.originalType=t,i.mdxType="string"==typeof t?t:a,c[1]=i;for(var s=2;s<r;s++)c[s]=n[s];return o.createElement.apply(null,c)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7435:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var o=n(7462),a=(n(7294),n(3905));const r={sidebar_position:4},c="Tutorial 4: How to deploy and call contract on the testnet",i={unversionedId:"Tutorials/how-to-deploy-and-call-contract-on-testnet",id:"Tutorials/how-to-deploy-and-call-contract-on-testnet",title:"Tutorial 4: How to deploy and call contract on the testnet",description:"Overview",source:"@site/docs/Tutorials/how-to-deploy-and-call-contract-on-testnet.md",sourceDirName:"Tutorials",slug:"/Tutorials/how-to-deploy-and-call-contract-on-testnet",permalink:"/scrypt-ts-docs/docs/Tutorials/how-to-deploy-and-call-contract-on-testnet",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Tutorials/how-to-deploy-and-call-contract-on-testnet.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Tutorial 3: Stateful Contract",permalink:"/scrypt-ts-docs/docs/Tutorials/stateful-contract"}},l={},s=[{value:"Overview",id:"overview",level:2},{value:"Setup",id:"setup",level:2},{value:"Instantiate the contract",id:"instantiate-the-contract",level:2},{value:"Deploy",id:"deploy",level:2},{value:"Call",id:"call",level:2}],p={toc:s};function d(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"tutorial-4-how-to-deploy-and-call-contract-on-the-testnet"},"Tutorial 4: How to deploy and call contract on the testnet"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"In previous tutorials, we've seen how to test and run contract locally. In this tutorial, we will show how to deploy and call contract on the testnet. "),(0,a.kt)("p",null,"We continue to develop on our ",(0,a.kt)("em",{parentName:"p"},"scrypt-ts-hello-world")," project."),(0,a.kt)("h2",{id:"setup"},"Setup"),(0,a.kt)("p",null,"Before we start writing the code to deploy the contract, we need to generate a ",(0,a.kt)("a",{parentName:"p",href:"https://en.bitcoin.it/wiki/Private_key"},"bitcoin privatekey")," and recharge some bitcoins to the address corresponding to the privatekey. You can use the following code to generate and save the privatekey:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { exit } from 'process';\nimport { bsv } from 'scryptlib';\nimport * as dotenv from 'dotenv';\nimport * as fs from 'fs';\n\nconst dotenvConfigPath = \".env\";\ndotenv.config({path: dotenvConfigPath});\n\n// fill in private key on testnet in WIF here\nconst privKey : string = process.env.PRIVATE_KEY || '';\nif (!privKey) {\n  genPrivKey();\n}\n\nexport function genPrivKey() {\n  const newPrivKey = bsv.PrivateKey.fromRandom('testnet')\n  console.log(`Missing private key, generating a new one ...\nPrivate key generated: '${newPrivKey.toWIF()}'\nYou can fund its address '${newPrivKey.toAddress()}' from sCrypt faucet https://scrypt.io/#faucet`);\n  // auto generate .env file with new generated key\n  fs.writeFileSync(dotenvConfigPath, `# You can fund its address '${newPrivKey.toAddress()}' from sCrypt faucet https://scrypt.io/#faucet\n  PRIVATE_KEY=\"${newPrivKey}\"`);\n  exit(-1)\n}\n\nexport const privateKey = bsv.PrivateKey.fromWIF(privKey);\n")),(0,a.kt)("center",null,(0,a.kt)("a",{href:"https://github.com/sCrypt-Inc/scrypt-ts-example/blob/master/privateKey.ts"},"privateKey.ts")),(0,a.kt)("p",null,"After the privatekey is generated, you can get some testnet bitcoins from our ",(0,a.kt)("a",{parentName:"p",href:"https://scrypt.io/#faucet"},"faucet"),"."),(0,a.kt)("p",null,"Deploy contracts and trigger contract execution by constructing transactions and sending them to the Bitcoin blockchain. We provide a tool library ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sCrypt-Inc/scrypt-ts-example/blob/f85dcf7a5d96979f39b5f512466bd9f4bdd22693/txHelper.ts#L32"},"txHelper.ts")," for building transactions."),(0,a.kt)("h2",{id:"instantiate-the-contract"},"Instantiate the contract"),(0,a.kt)("p",null,"This is the same as instantiating the contract in the ",(0,a.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/docs/Tutorials/how-to-test-contract#instantiate-the-contract"},"Tutorial 2"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"Demo.compile().then(async ()=> {\n    let demo = new Demo(1n, 2n);\n})\n")),(0,a.kt)("h2",{id:"deploy"},"Deploy"),(0,a.kt)("p",null,"Next, we implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"deploy()")," function for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Demo")," contract, which implements the following main steps:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Get the available utxos for the privatekey"),(0,a.kt)("li",{parentName:"ul"},"Construct a transaction: the input of which is the acquired utxos, and the first output of the transaction contains the lockingScript corresponding to the Demo contract"),(0,a.kt)("li",{parentName:"ul"},"Sign and broadcast transaction with privatekey")),(0,a.kt)("p",null,"The final code is as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"async deploy(satoshis: number) {\n\n    // 1. Get the available utxos for the privatekey\n    const utxos = await fetchUtxos();\n\n    // 2. Construct a transaction: the input of which is the acquired utxos, and the first output of the transaction contains the lockingScript corresponding to the Demo contract\n    const tx = newTx(utxos);\n    tx.addOutput(new bsv.Transaction.Output({\n        script: this.lockingScript,\n        satoshis: satoshis,\n    }));\n\n    // 3. Sign and broadcast transaction with privatekey\n    return signAndSend(tx);\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NOTE:")," The deploy function implements the function of deploying the contract, not the logic of the contract itself, so ",(0,a.kt)("inlineCode",{parentName:"p"},"@method")," decorator should not be added."),(0,a.kt)("p",null,"Call ",(0,a.kt)("inlineCode",{parentName:"p"},"deploy()")," function to deploy the ",(0,a.kt)("inlineCode",{parentName:"p"},"Demo")," contract to the network:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"Demo.compile().then(async ()=> {\n    let demo = new Demo(1n, 2n);\n\n    const deployTx = await demo.deploy(1000);\n\n    console.log('contract deployed: ', deployTx.id)\n})\n")),(0,a.kt)("p",null,"You will see the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"contract deployed:  e5924840a74280d0313c7ff5964370cc203d728120c9145288a579ac6848ea28\n")),(0,a.kt)("p",null,"Visit ",(0,a.kt)("inlineCode",{parentName:"p"},"https://test.whatsonchain.com/tx/e5924840a74280d0313c7ff5964370cc203d728120c9145288a579ac6848ea28")," to see the transaction in the testnet."),(0,a.kt)("h2",{id:"call"},"Call"),(0,a.kt)("p",null,"Once a smart contract is successfully deployed, it must be executed with the correct parameters. We construct the transaction and set the correct unlocking parameters to call the contract."),(0,a.kt)("p",null,"Now we implement a function that calls the ",(0,a.kt)("inlineCode",{parentName:"p"},"add")," public function of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Demo")," contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"async callAdd(z: bigint, prevTx: bsv.Transaction) {\n\n    let tx: bsv.Transaction = new bsv.Transaction()\n        .addInput(createInputFromPrevTx(prevTx))\n        .setInputScript(0, (tx: bsv.Transaction, prevOutput: bsv.Transaction.Output) => {\n            return this.getUnlockingScript(() => {\n                // call previous demo's public method to get the unlocking script.\n                this.add(z)\n            })\n        })\n\n    return signAndSend(tx);\n}\n")),(0,a.kt)("p",null,"This code uses ",(0,a.kt)("inlineCode",{parentName:"p"},"prevTx")," as input for the current transaction and sets the unlockingScript via ",(0,a.kt)("inlineCode",{parentName:"p"},"setInputScript"),". Note that you need to call the public function of the contract in the callback method of ",(0,a.kt)("inlineCode",{parentName:"p"},"getUnlockingScript()")," to get the corresponding unlockingScript."),(0,a.kt)("p",null,"Only transactions containing the correct unlockingScript can be accepted by the blockchain, and the transaction can spend the utxo where the contract is located (that is, execute the contract)."),(0,a.kt)("p",null,"Then, also call ",(0,a.kt)("inlineCode",{parentName:"p"},"signAndSend")," to sign and broadcast the transaction."),(0,a.kt)("p",null,"Call ",(0,a.kt)("inlineCode",{parentName:"p"},"callAdd()")," function to run the ",(0,a.kt)("inlineCode",{parentName:"p"},"Demo")," contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"Demo.compile().then(async ()=> {\n    let demo = new Demo(1n, 2n);\n\n    const deployTx = await demo.deploy(1000);\n\n    console.log('contract deployed: ', deployTx.id);\n\n    const calledTx = await demo.callAdd(3n, deployTx);\n\n    console.log('contract called: ', calledTx.id);\n})\n")),(0,a.kt)("p",null,"You will see the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"contract called:  fd1e276ba344f51fa972366b6eed60fae99bce7c3d339b9e2389067a92bc7648\n")),(0,a.kt)("h1",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"We have finished deploying and calling ",(0,a.kt)("inlineCode",{parentName:"p"},"Demo")," contract on the testnet."))}d.isMDXComponent=!0}}]);