"use strict";(self.webpackChunkscrypt_ts_docs=self.webpackChunkscrypt_ts_docs||[]).push([[0],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,h=m["".concat(s,".").concat(u)]||m[u]||c[u]||r;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2546:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:2},l="How to Write a Contract",o={unversionedId:"getting-started/how-to-write-a-contract",id:"getting-started/how-to-write-a-contract",title:"How to Write a Contract",description:"A contract can be written as a class that extends the SmartContract base, a simple example could be like this:",source:"@site/docs/getting-started/how-to-write-a-contract.md",sourceDirName:"getting-started",slug:"/getting-started/how-to-write-a-contract",permalink:"/scrypt-ts-docs/getting-started/how-to-write-a-contract",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/scrypt-ts-docs/getting-started/installation"},next:{title:"How to Test a Contract",permalink:"/scrypt-ts-docs/getting-started/how-to-test-a-contract"}},s={},p=[{value:"Properties",id:"properties",level:2},{value:"<code>@prop(state)</code> decorator",id:"propstate-decorator",level:3},{value:"Constructor",id:"constructor",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>@method</code> decorator",id:"method-decorator",level:3},{value:"Public/Entry <code>@method</code>s",id:"publicentry-methods",level:3},{value:"Non-Public/Non-Entry <code>@method</code>s",id:"non-publicnon-entry-methods",level:3},{value:"Types",id:"types",level:2},{value:"Basic Types",id:"basic-types",level:3},{value:"<code>string</code> Type",id:"string-type",level:4},{value:"<code>number</code> Type",id:"number-type",level:4},{value:"User-defined Types",id:"user-defined-types",level:3},{value:"Array Types",id:"array-types",level:3},{value:"Domain Types",id:"domain-types",level:3},{value:"<code>SmartContract</code> subclasses Types",id:"smartcontract-subclasses-types",level:3},{value:"Variables",id:"variables",level:2},{value:"Compile-time Constant",id:"compile-time-constant",level:3},{value:"Statements",id:"statements",level:2},{value:"<code>for</code> statement",id:"for-statement",level:3},{value:"<code>return</code> statement",id:"return-statement",level:3},{value:"Functions",id:"functions",level:2},{value:"Built-in Functions",id:"built-in-functions",level:3},{value:"<code>assert</code> Function",id:"assert-function",level:4},{value:"Whitelisted Functions",id:"whitelisted-functions",level:3},{value:"<code>console.log</code> Function",id:"consolelog-function",level:4}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-to-write-a-contract"},"How to Write a Contract"),(0,i.kt)("p",null,"A contract can be written as a class that extends the ",(0,i.kt)("inlineCode",{parentName:"p"},"SmartContract")," base, a simple example could be like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { SmartContract, method, prop, assert } from "scrypt-ts";\n\nclass Demo extends SmartContract {\n  @prop()\n  x: bigint;\n\n  constructor(x: bigint) {\n    super(x);\n    this.x = x;\n  }\n\n  @method\n  public unlock(x: bigint) {\n    assert(this.add(this.x, 1n) === x);\n  }\n\n  @method\n  add(x0: bigint, x1:bigint) : bigint {\n    return x0 + x1;\n  }\n}\n')),(0,i.kt)("h2",{id:"properties"},"Properties"),(0,i.kt)("p",null,"A contract class can have two kinds of properties:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Properties without ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop")," decorator. These properties are just like normal typescript class properties with no special restraints.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Properties with ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop")," decorator. These properties are ",(0,i.kt)("strong",{parentName:"p"},"only allowed to have ",(0,i.kt)("a",{parentName:"strong",href:"#Types"},"types")," specified below")," and they shall only be initialized in the constructor."))),(0,i.kt)("h3",{id:"propstate-decorator"},(0,i.kt)("inlineCode",{parentName:"h3"},"@prop(state)")," decorator"),(0,i.kt)("p",null,"Use this decorator on class properties to mark them as contract properties, which means the values would be stored on-chain within ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.bitcoinsv.io/index.php/Bitcoin_Transactions"},"tx"),"."),(0,i.kt)("p",null,"This decorator can take a boolean parameter, which indicates whether it can be updated later. If the value is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", the property is so called a ",(0,i.kt)("inlineCode",{parentName:"p"},"stateful")," property and its value stored on chain can be updated between contract calls; otherwise, its value can not be changed since the contract deployed."),(0,i.kt)("h2",{id:"constructor"},"Constructor"),(0,i.kt)("p",null,"A contract class should have an explicit constructor if it has at least one ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop"),"s. "),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"super")," method should be called in the constructor and be provided with all the initial values of ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop"),"s in their declaration orders. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"class A extends SmartContract {\n  p0: string;\n  @prop() p1: bigint;\n  @prop() p2: boolean;\n  constructor(p0: string, p1: bigint, p2: boolean) {\n    super(p1, p2);  // Do not pass in `p0` bcoz it\u2019s not a `@prop`, also note that `p1` & `p2` should be passed in order.\n    this.p0 = p0;\n    this.p1 = p1;\n    this.p2 = p2;\n  }\n}\n")),(0,i.kt)("h2",{id:"methods"},"Methods"),(0,i.kt)("p",null,"Like properties, a contract can also have two kinds of methods:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Methods without ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," decorator. These methods are just like normal typescript class methods with no special restraints.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Methods with ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," decorator. These methods should follow the restraints described below:"))),(0,i.kt)("p",null,"Within these methods, ",(0,i.kt)("strong",{parentName:"p"},"only ",(0,i.kt)("a",{parentName:"strong",href:"#Functions"},"functions")," specified below or methods also decorated by ",(0,i.kt)("inlineCode",{parentName:"strong"},"@method")," can be called"),"; Similarly, ",(0,i.kt)("strong",{parentName:"p"},"only the properties decorated by ",(0,i.kt)("inlineCode",{parentName:"strong"},"@prop")," can be visited"),"."),(0,i.kt)("h3",{id:"method-decorator"},(0,i.kt)("inlineCode",{parentName:"h3"},"@method")," decorator"),(0,i.kt)("p",null,"Use this decorator on class methods to mark them as contract methods. The logic implemented in these methods would be serialized into ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.bitcoinsv.io/index.php/Bitcoin_Transactions"},"tx")," and be executed on chain."),(0,i.kt)("h3",{id:"publicentry-methods"},"Public/Entry ",(0,i.kt)("inlineCode",{parentName:"h3"},"@method"),"s"),(0,i.kt)("p",null,"With a ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," modifier, a ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," is marked as an entry method that could be called outside the contract class, especially when building a tx. "),(0,i.kt)("p",null,"The main purpose of these methods is to validate / verify / check assertions for its input parameters according to its ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop")," decorated properties. "),(0,i.kt)("p",null,"Their return value must be ",(0,i.kt)("inlineCode",{parentName:"p"},"void"),". For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"  @method\n  public unlock(x: bigint) {\n    assert(this.add(this.x, 1n) === x);\n  }\n")),(0,i.kt)("h3",{id:"non-publicnon-entry-methods"},"Non-Public/Non-Entry ",(0,i.kt)("inlineCode",{parentName:"h3"},"@method"),"s"),(0,i.kt)("p",null,"Without a ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," modifier, a ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," is marked as an inner function, which is usually called within the contract class. "),(0,i.kt)("p",null,"It can return any valid types described later. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"  @method\n  add(x0: bigint, x1:bigint) : bigint {\n    return x0 + x1;\n  }\n")),(0,i.kt)("h2",{id:"types"},"Types"),(0,i.kt)("p",null,"The types can be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," are restricted to these kinds:"),(0,i.kt)("h3",{id:"basic-types"},"Basic Types"),(0,i.kt)("p",null,"The most commonly basic types allowed are: ",(0,i.kt)("inlineCode",{parentName:"p"},"boolean")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"bigint"),", along with their wrapper types ",(0,i.kt)("inlineCode",{parentName:"p"},"Boolean")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"Bigint"),"."),(0,i.kt)("h4",{id:"string-type"},(0,i.kt)("inlineCode",{parentName:"h4"},"string")," Type"),(0,i.kt)("p",null,"All the ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," type variables in ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s or ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop"),"s should have values in a hex bytes format, which could be represented by a regular expression: ",(0,i.kt)("inlineCode",{parentName:"p"},"/^([0-9a-fA-F]{2})*$/"),"."),(0,i.kt)("p",null,"So literal ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," is not allowed to be used directly without wrapping in these functions below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"b(input: string)"),": Will return the raw value of ",(0,i.kt)("inlineCode",{parentName:"li"},"input")," while validating it as hex bytes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"u8b(input: string)"),": Will return a value in hex bytes format representing the utf8 encoding of ",(0,i.kt)("inlineCode",{parentName:"li"},"input"),".")),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let s0 = u8b('hello world');  // valid, s0 === \"68656c6c6f20776f726c64\"\n\nlet s1 = b('01ab23ef');       // valid, s1 === '01ab23ef'\n\nlet invalid_str = \"hello world\";  // invalid, string literal without wrapper function\n\nlet invalid_str2 = b('012'); // invalid, odd number of hex characters\n")),(0,i.kt)("p",null,"Also there are only two methods of ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," can be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String.slice(indexStart, indexEnd)"))),(0,i.kt)("p",null,"To get a substring like ",(0,i.kt)("inlineCode",{parentName:"p"},"str.slice(0, 2)"),", since the ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," is in hex bytes format, ",(0,i.kt)("inlineCode",{parentName:"p"},"indexStart")," & ",(0,i.kt)("inlineCode",{parentName:"p"},"indexEnd")," should be even numbers."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"String.+"))),(0,i.kt)("p",null,"To concat strings, like ",(0,i.kt)("inlineCode",{parentName:"p"},"str1 + str2"),"."),(0,i.kt)("h4",{id:"number-type"},(0,i.kt)("inlineCode",{parentName:"h4"},"number")," Type"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"number")," type variables are often not allowed in ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop"),"s and ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s because it may cause precision issues when representing a floating point number. "),(0,i.kt)("p",null,"But it can be used in a few cases when the variable is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A compile-time constant")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const N: number = 2;\nlet arr: FixedArray<bigint, N> = [1n, 2n];\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An array index")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let idx : number = 3;\nlet item = arr[idx];\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An induction variable in ",(0,i.kt)("inlineCode",{parentName:"li"},"for")," statement")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"for(let i: number =0; i < 5; i++) \u2026\n")),(0,i.kt)("h3",{id:"user-defined-types"},"User-defined Types"),(0,i.kt)("p",null,"They can be defined using ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"interface"),", made of basic types. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type ST = {\n  a: bigint;\n  b: boolean;\n}\n\ninterface ST1 {\n  x: ST;\n  y: string;\n}\n")),(0,i.kt)("h3",{id:"array-types"},"Array Types"),(0,i.kt)("p",null,"The common array types in Typescript like ",(0,i.kt)("inlineCode",{parentName:"p"},"T[]")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Array<T>")," are not allowed to be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"@prop"),"s and ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s. "),(0,i.kt)("p",null,"They ",(0,i.kt)("strong",{parentName:"p"},"must")," be declared as type of ",(0,i.kt)("inlineCode",{parentName:"p"},"FixedArray<T, LENGTH>"),", whose ",(0,i.kt)("inlineCode",{parentName:"p"},"LENGTH")," should be a ",(0,i.kt)("a",{parentName:"p",href:"#compile-time-constant"},"CTC")," value described later, like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let aaa: FixedArray<bigint, 3> = [1n, 3n, 3n];\n\nconst N = 2;\nlet aab: FixedArray<bigint, N> = [1n, 2n];\n\n// 2-dimensional array\nlet abb: FixedArray<FixedArray<bigint, 2>, 3> = [[1n, 3n], [1n, 3n], [1n, 3n]];\n")),(0,i.kt)("h3",{id:"domain-types"},"Domain Types"),(0,i.kt)("p",null,"There are several domain types, specific to the Bitcoin SV context, used to further improve type safety."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/PubKey"},"PubKey")," - a public key type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/PrivKey"},"PrivKey")," - a private key type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/Sig"},"Sig")," - a signature type in DER format, including signature hash type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/Ripemd160"},"Ripemd160")," - a RIPEMD-160 hash type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/PubKeyHash"},"PubKeyHash")," - an alias for Ripemd160` type. Usually represents a bitcoin address.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/Sha1"},"Sha1")," - a SHA-1 hash type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/Sha256"},"Sha256")," - a SHA-256 hash type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/SigHashType"},"SigHashType")," - a sighash type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/SigHashPreimage"},"SigHashPreimage")," - a sighash preimage type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"/scrypt-ts-docs/reference/classes/OpCodeType"},"OpCodeType")," - a OpCode type."))),(0,i.kt)("h3",{id:"smartcontract-subclasses-types"},(0,i.kt)("inlineCode",{parentName:"h3"},"SmartContract")," subclasses Types"),(0,i.kt)("p",null,"They are provided as libraries."),(0,i.kt)("h2",{id:"variables"},"Variables"),(0,i.kt)("p",null,"Variables can be declared normally in ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s by keywords ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"let"),", like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let a : bigint = 1n;\nvar b: boolean = false;\nconst N: number = 3;\n")),(0,i.kt)("h3",{id:"compile-time-constant"},"Compile-time Constant"),(0,i.kt)("p",null,"A compile-time constant, CTC for short, is a special variable whose value can be determined at compile time. There are three kinds of commonly used CTCs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A number literal like:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"3;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," variable name like:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const N = 3;\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"readonly")," property name like:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class X {\n  static readonly N = 3;\n}\n")),(0,i.kt)("p",null,"They can be used at places where a CTC is required, like:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Array length in declaration")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"FixedArray<bigint, 3>\nFixedArray<bigint, N>\nFixedArray<bigint, X.N>\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Loop count in ",(0,i.kt)("inlineCode",{parentName:"li"},"for")," statement")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"for(let i=0; i< 3; i++)\nfor(let i=0; i< N; i++)\nfor(let i=0; i< X.N; i++)\n")),(0,i.kt)("h2",{id:"statements"},"Statements"),(0,i.kt)("p",null,"There are also some other restraints / rules on the statements that could be used within the ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s besides the previously mentioned."),(0,i.kt)("h3",{id:"for-statement"},(0,i.kt)("inlineCode",{parentName:"h3"},"for")," statement"),(0,i.kt)("p",null,"Because of the underlying limitation of ",(0,i.kt)("inlineCode",{parentName:"p"},"loop")," implementation on Bitcoin script, one can only use a compile time const number as the loop iterations."),(0,i.kt)("p",null,"So currently if you want to build a loop inside ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s, there is only one restricted version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," statement that could be used. It's looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"for(let $i = 0; $i < $ctcNum; $i++) {\n  ...\n}\n")),(0,i.kt)("p",null,"Note that the initial value ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"<")," operator and the post unary operator ",(0,i.kt)("inlineCode",{parentName:"p"},"++")," are all unchangeable."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"$i")," can be whatever you named the induction variable;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"$ctcNum")," should be an expression of a ",(0,i.kt)("a",{parentName:"p",href:"#compile-time-constant"},"CTC")," numeric value described before."))),(0,i.kt)("h3",{id:"return-statement"},(0,i.kt)("inlineCode",{parentName:"h3"},"return")," statement"),(0,i.kt)("p",null,"Due to a certain underlying limitation, ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement in a ",(0,i.kt)("inlineCode",{parentName:"p"},"@method")," is only allowed to appear at the last statement of a function. Returning from the middle is not allowed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@method m(x: bigint): bigint {\n   if (x > 2n) return x; // invalid\n   return x + 1n;  // valid\n}\n")),(0,i.kt)("h2",{id:"functions"},"Functions"),(0,i.kt)("p",null,"As described before, all Javascript/Typescript built-in functions/global variables are not allowed in ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s, except the following kinds."),(0,i.kt)("h3",{id:"built-in-functions"},"Built-in Functions"),(0,i.kt)("h4",{id:"assert-function"},(0,i.kt)("inlineCode",{parentName:"h4"},"assert")," Function"),(0,i.kt)("p",null,"The most commonly used built-in function is the ",(0,i.kt)("inlineCode",{parentName:"p"},"assert(cond: boolean)")," function. It throws a runtime error if ",(0,i.kt)("inlineCode",{parentName:"p"},"cond")," is false and interrupts a contract call. That means if and only if all the ",(0,i.kt)("inlineCode",{parentName:"p"},"assert")," functions return normally, a contract call can be successful."),(0,i.kt)("h3",{id:"whitelisted-functions"},"Whitelisted Functions"),(0,i.kt)("p",null,"There are also some whitelisted Javascript/Typescript functions that can be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"@method"),"s."),(0,i.kt)("h4",{id:"consolelog-function"},(0,i.kt)("inlineCode",{parentName:"h4"},"console.log")," Function"),(0,i.kt)("p",null,"One exceptional statement is ",(0,i.kt)("inlineCode",{parentName:"p"},"console.log"),", which can be used for debugging purposes."))}c.isMDXComponent=!0}}]);